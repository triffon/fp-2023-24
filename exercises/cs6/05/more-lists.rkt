#lang racket

; Предния път работихме със списъци и реализирахме
; функции като accumulate - foldl и foldr

(foldr + 0 '(1 2 3 4)) ; 10
(foldl + 0 '(1 2 3 4)) ; 10

; Да припомним разликата...

; foldr сгъва списъка от дясно наляво:
;-------------------------------------
; (+ 1 (+ 2 (+ 3 (+ 4 0))))
; foldr генерира рекурсивен процес
; и тези операции са отложени

; т.е. можете да се възползвате от това,
; ако искате операциите ви да се изпълнят в обратен ред

; foldl сгъва списъка от ляво надясно:
;-------------------------------------
; (+ 4 (+ 3 (+ 2 (+ 1 0))))
; foldl генерира итеративен процес и операциите се
; изчисляват в аргумента.

; NOTE: Нормалния foldl (както работи и в Haskell)
;       има по-различна имплементация:
;       (+ (+ (+ (+ 0 1) 2) 3) 4)
; Разликата е в реда на аргументите на операцията.

; В Racket:
; (foldl - 0 '(1 2 3 4)) -> 2
; (4 - (3 - (2 - (1 - 0))))

; В Haskell:
; (foldl - 0 '(1 2 3 4)) -> -10
; ((((0 - 1) - 2) - 3) - 4)


; В scheme има функции, които могат да приемат
; произволен брой аргументи:
;---------------------------
; map на много аргументи
(map + '(1 2 3) '(4 5 6)) ; '(5 7 9)
; списъците трябва да имат еднаква дължина

; apply прилага функция над списък от аргументи
(apply + '(1 2 3 4 5)) ; 15
(apply max '(1 2 3 11 4 5)) ; 11

; apply има вида: (apply proc v1 ... vn lst kw-arg ...)
; Засега не се интересуваме от kw-arg.
; Освен подадения списък, apply може да приема и
; допълнителни аргументи към подадената процедура proc.
; Това са онези v1 ... vn

; Тук 2 е допълнителен аргумент към *
(apply * 2 '(1 2 3)) ; 12
; същото като:
(* 2 1 2 3)

; Тук + е допълнителен аргумент към map:
(apply map + '((1 2 3) (4 5 6))) ; '(5 7 9)
; същото като:
(map + '(1 2 3) '(4 5 6))

; Ето и един пример с транспониране на матрица
(define (transpose m)
  (apply map list m))

; Разписваме transpose:
; (apply map list '((1 2 3) (4 5 6) (7 8 9)))
; <=>
; (map list '(1 2 3) '(4 5 6) '(7 8 9))
; <=>
; (list (list 1 4 7)
;       (list 2 5 8)
;       (list 3 6 9))

; Можем да правим функции на произволен брой аргументи
; (lambda (args . opt-args) <body>)
; Където "args" са задължителните параметри,
; а "opt-args" е списък с допълнителни (optional) аргументи.
(lambda (x . lst) (apply + (cons x lst)))

; Вече знаем че define е синтактична захар за свързване
; на символ с ламбда.
; Съответно дефинираме такива функции с define така:
(define (sum x . l) (foldl + 0 (cons x l)))


;===============;=========================================
;; З А Д А Ч И ;;
;;;;;;;;;;;;;;;;;

(define (foldl* op acc lst)
  (if (null? lst)
      acc
      (foldl* op
              (op acc (car lst))
              (cdr lst))))

(define (foldr* op acc lst)
  (if (null? lst)
      acc
      (op (car lst)
          (foldr* op acc (cdr lst)))))

; Реализирайте чрез foldl* или foldr*:
;-------------------------------------
; 1. Намира дължина на списък
(define (length* lst) 'undefined)

; 2. Премахва повторенията на елементи в lst
; HINT: member
(define (uniques lst) 'undefined)

; 3. Проверява дали p? е верен за точно n елемента от lst
(define (sat-n? p? n lst) 'undefined)

; 4. Връща списък с елементите на lst, но в обратен ред.
(define (reverse* lst) 'undefined)

; 5. Намира броя на елементите в дълбокия списък lst.
; Тоест lst може да има произволни нива на вложеност.
; Пример: (count-atoms '((1 2 3 (4)) (5 ((6))) 7) ) -> 7
(define (count-atoms lst) 'undefined)

; 6. Връща наредена двойка (fst . snd),
; където fst е списък от елементите за които p? е истина
; и snd е списък от елементите за които p? е лъжа
; Пример: (partition* even? '(1 2 3 4 5)) -> ((2 4) 1 3 5)
(define (partition* p? lst) 'undefined)

; Функции на много аргументи:
; HINT: Използвайте apply
;----------------------------
; 7. Средно аритметично на много аргументи
(define (avg h . t) 'undefined)

; 8. Композиция на на много едноаргументни функции
; Пример: ((compose-all (^2) succ) 5) -> 36
(define (compose-all f . gs) 'undefined)

; 9. Конюнкция на много едноместни предикати
; Пример: ((conjoint-all even? >10) 4) -> #t
(define (conjoint-all p? . preds) 'undefined)

; 10. Като map на много аргументи, но трябва да работи за
; списъци с различни дължини.
(define (zipWith f . lsts) 'undefined)
