#lang racket

; THROWBACK:
;-----------
; - рекурсия и итерация
; - функциите в които всички рекурсивни извиквания са
;   опашкови, генерират итеративен рекурсивен процес
; - не всички функции могат да бъдат изчислени с итерация

; Видяхме че можем да пишем итеративни функции, като
; пазим резултата в допълнителна променлива.
(define (interval-sum-i a b)
  (define (iter i j acc)
    (if (= i j)
      (+ acc i)
      (iter (+ i 1)
            j
            (+ acc i))))
    (iter a b 0))

; Какво ако искаме да умножим числата в интервала?

; Можем да се абстрахираме от операцията и да напишем
; функция, която може да използва произволна операция
; за горното изчисление.

; Обаче ако искаме да умножаваме числата,
; освен замяната на (+) с (*),
; ще трябва и да извикаме (iter a b 1),
; защото неутралния елемент спрямо умножението е 1, а не 0.

; Затова просто ще напишем итеративна функция без вложена
; дефиниция, и ще оставим потребителя да подаде начална
; стойност.

; В замяна получаваме по-обща функция, която можем да
; ползваме за повече неща.

(define (interval-op from to op acc)
  (if (> from to)
    acc
    (interval-op
      (+ from 1)
      to
      op
      (op acc from))))

; TODO: Още за задача 1

;===============;=========================================
;; З А Д А Ч И ;;
;;;;;;;;;;;;;;;;;

; Идентитета не е част от racket и R5RS, но ще ви потрябва
(define (id x) x)

; 1. Да се напише итеративна функция, която за дадени:
; - [from, to] - интервал от числа
; - term - едноаргументна функция над цели числа
; - op - бинарна операция над acc и term(x)
; - acc - начална стойност
; Пресмята натрупаната стойност в acc, получена чрез
; обхождане на интервала [from, to] с операция op
; над стойностите получени чрез term(x)
;
; Пример: Сума на квадратите на числата от 1 до 10
; (accumulate 1 10 (lambda (x) (expt x 2)) + 0)
(define (accumulate from to term op acc) 'undefined)

; Реализирайте следните функции чрез accumulate:
; (Или чрез извикване на някоя друга от долните ф-ии)
;----------------------------------------------------
; 2. Факториел.
(define (fact n) 'undefined)

; 3. Проверява дали даден предикат е верен за всички числа
; в даден интервал.
; Hint: вместо да ползвате директно and и or -
; (define (and2 x y) (and x y))
(define (for-all? from to p?) 'undefined)

; 4. Проверява дали някое число в даден интервал
; изпълнява даден предикат.
(define (exists? from to p?) 'undefined)

; 5. Намира броя на целите числа в интервал,
; които изпълняват даден предикат.
(define (count-p from to p?)'undefined)

; 6. Проверява дали дадено число е просто
(define (prime? p) 'undefined)

; 7. Намира броя на простите числа в даден интервал
(define (primes from to) 'undefined)

; 8. Проверява дали в целочисления интервал [a,b]
; съществуват две различни цели числа x и y, такива че:
; f(x) = g(x) и f(y) = g(y)
; Примери:
;   (meetTwice? id (lambda (x) (- x)) -3 1) -> #f
;   (meetTwice? id sqrt 0 5) -> #t (за 0 и 1)
(define (meet-twice f g a b) 'undefined)

; 9. Обръща записа на дадено естествено число
; Hint: (count-digits n) <=> (+ 1 (floor (log n 10)))
(define (reverse-digits n) 'undefined)

; 10. Намира броя на палиндромите в интервала [a,b]
(define (count-palindromes a b) 'undefined)

; 11. Намира средната цифра на записа на дадено число.
; Ако n има четен брой цифри, функцията връща -1.
; Примери:
;   (middle-digit 452) -> 5
;   (middle-digit 4712) -> -1
(define (middle-digit n) 'undefined)
