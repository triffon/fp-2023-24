#lang racket

; Функции от миналия път за асоциативни списъци:
;-----------------------------------------------
(define (make-alist fn keys)
  (map (lambda (key)
         (cons key (fn key))) keys))

(define (add-assoc key value alist)
  (cons (cons key value)
        alist))

(define (alist-keys alist)
  (map car alist))

(define (alist-values alist)
  (map cdr alist))

(define (alist-assoc key alist)
  (cond ((null? alist) '())
        ((equal? (caar alist) key) (cdar alist))
        (else (alist-assoc key (cdr alist)))))

(define (del-assoc key alist)
  (filter (lambda (alist-pair)
            (not (equal? (car alist-pair) key)))
          alist))

; Графи:
;-------
; Граф ще представяме като списък на съседство
; Тоест списък от списъци от върхове.
; За връх v ще дефинираме списък (v v1 .. vn)
; Където v1 до vn са върховете до които v има ребро
; За всеки връх ще пазим такъв списък.
; Списъка от тези списъци ще е нашият граф.
;
; 1 --> 2
; |     |
; v     v
; 3 --> 4 --> 5
;
; Горният граф бихме представили по следния начин:
'((1 2 3) ; 1 има ребро до 2 и 3
  (2 4)   ; 2 има ребро до 4
  (3 4)   ; 3 има ребро до 4
  (4 5)   ; 4 има ребро до 5
  (5))    ; 5 няма ребра до други върхове

'() ; празен граф
'((1 2 3) (2))
; ^ Невалидно защото твърдим че 1 има ребро до 3,
; но не сме включили списък за реброто 3

; Как да си създадем граф?
; Може да го конструираме само с върхове и без ребра
(define (make-graph vs)
  (map list vs))

; Още няколко функции за работа с графи:

; Проверка дали граф е празен
(define empty-graph? null?)

; Върховете на граф g са точно първите елементи
; на подсписъците на g.
; Тост g е списък от двойки и върховете са първите елементи
(define vertices alist-keys)

; За да добавим нов връх - добавяме списък от върха v.
; Той първоначално няма ребра до други върхове.
(define (add-vertex v g)
  (cons (list v) g))


; Отложени операции:
;-------------------
; delay от даден израз прави отложена операция (promise)
(delay (+ 1 2)) ; #<promise>

; force взима отложена операция и я оценява
(force (delay (+ 1 2))) ; 3

; Можем да симулираме delay и force чрез lambda


; Потоци:
;--------
; С помощта на delay и force можем да си дефинираме потоци:
; 1) '() е поток
; 2) (h . t) е поток <=> t е promise за списък

(define empty-stream '())

; За да постигнем това операцията cons ще трябва да прави
; нещо повече - да прилага delay върху 2рия елемент
; (define (cons-stream h t)
;   (cons h (delay t)))

; Проблем - delay е специална форма, но cons-stream
; не е и за нея важи стриктно оценяване.

(define-syntax cons-stream
  (syntax-rules () ((cons-stream h t)
                    (cons h (delay t)))))

; Пример за функция, генерираща безкраен поток:
(define (repeat v)
  (cons-stream v (repeat v)))
; Тук ако бяхме използвали първия вариант на cons-stream,
; програмата ни щеше да се опита да изпълни безкрайната
; рекурсия и щеше да забие.


; Ето и базовите функции за работа с потоци:
;-------------------------------------------
; Когато ни трябва елемент от потока просто го взимаме
; (той е първият)
(define head car)

; Когато искаме да вземем опашката на потока,
; я оценяваме с force
(define (tail s)
  (force (cdr s)))

; Доста често ще искаме да взимаме елементи от поток.
; Функцията take за потоци:
(define (stream-take* n s)
  (if (or (zero? n) (null? s))
    '()
    (cons (head s)
          (stream-take* (- n 1) (tail s)))))


;===============;=========================================
;; З А Д А Ч И ;;
;;;;;;;;;;;;;;;;;

; За потоци:
;-----------
; Генерира безкрайния поток x, f(x), f(f(x)), ...
(define (iterate f x)  'undefined)

; Генерира безкраен поток от елементите на lst.
; (cycle '(1 2 3)) -> 1, 2, 3, 1, 2, 3, 1 ...
(define (cycle lst) 'undefined)

; Прилага едноаргументна функция f
; над елементите на безкраен поток s.
(define (stream-map* f s) 'undefined)

; Генерира безкраен поток от естествените числа
(define nats 'undefined)


; За работа с графи:
;-------------------
; Може да ползвате горните функции за асоциативни списъци
; Не забравяйте че списъците са двойки,
; тоест списък от списъци всъщност е асоциативен списък.
; (стига да няма празни списъци като елементи)

; Връща списък от всички ребра* на графа g.
; * т.е. двойки върхове (x . y),
; такива че има ребро от x към y
(define (edges g) 'undefined)

; Проверява дали има ребро от върха u до върха v в g.
(define (edge? u v g) 'undefined)

; Връща списък от децата на върха v в g.
(define (children v g) 'undefined)

; Връща списък от прилаганията на функцията f
; върху децата на v в g.
(define (map-children v f g) 'undefined)

; Връща първото дете на v в g, за което предиката p
; е верен.
(define (search-child v p g) 'undefined)

; Премахване на върха v от графа g,
; заедно с ребрата до него.
(define (remove-vertex v g) 'undefined)

; Добавяне на ребро от u до v в g.
(define (add-edge u v g) 'undefined)

; Премахване на ребро от u до v в g.
(define (remove-edge u v g) 'undefined)


; За графи:
;----------
; Връща степента на върха v в графа g.
(define (degree v g) 'undefined)

; Проверява дали графа g е симетричен.
(define (symmetric? g) 'undefined)

; Инвертира графа g.
; Тоест за всяко ребро (u,v) в g новият граф
; ще има реброто (v,u).
(define (invert g) 'undefined)

; Проверява дали има път между върховете u и v в графа g.
(define (path? u v g) 'undefined)

; Проверява дали графа g е ацикличен.
(define (acyclic? g) 'undefined)

; Бонус: DFS и BFS
; За даден граф, върнете списък от върховете в реда на обхождането му
; Hint: допълнителна променлива(списък) за посетените върхове
