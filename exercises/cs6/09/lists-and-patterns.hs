-- cover all cases!
{-# OPTIONS_GHC -fwarn-incomplete-patterns #-}
-- warn about incomplete patterns v2
{-# OPTIONS_GHC -fwarn-incomplete-uni-patterns #-}
-- write all your toplevel signatures!
{-# OPTIONS_GHC -fwarn-missing-signatures #-}
-- use different names!
{-# OPTIONS_GHC -fwarn-name-shadowing #-}
-- use all your pattern matches!
{-# OPTIONS_GHC -fwarn-unused-matches #-}

import Prelude hiding (foldl, map, pi, takeWhile, zip, zipWith)

-- pattern matching (съпоставяне на образци):
--------------------------------------------
-- Можем да правим нещо като cond в scheme - guards:
factGuards :: Int -> Int
factGuards n
  | n == 0 = 1
  | otherwise = n * factGuards (n - 1)

-- Сега същата функция, но дефинирана с case синтаксис:
factCase :: Int -> Int
factCase n = case n of
  0 -> 1
  k -> k * factCase (k - 1)

-- Какво ни прави впечатление?
-- При case не използваме булева проверка (== 0) за базовия случай,
-- a в общия случай преименувахме променливата от n на k.
-- Това е защото нещата от левия край на (->) в case синтаксиса са образци.

-- видове образци:
-- - литерал (константа) - съвпада с конкретна стойност
-- - променлива с име - съвпада с произволна стойност, свързва я с името
-- - анонимен образец "_" - съвпада с произволна стойност, не я свързва с име

-- Можем да дефинираме функции като поредица от равенства
-- (синтактична захар за case)

-- Все едно даваме различна дефиниция на функцията спрямо входните данни.
-- А вида на входните данни подбираме чрез образци.
--
-- Важно е да покрием всички случаи!

-- Примери:
fact :: Int -> Int
fact 0 = 1 -- получили сме 0 и директно връщаме 1
fact n = n * fact (n - 1)

-- получили сме някакво число и му даваме името "n".
-- със сигурност не е 0,
-- защото проверката на дефинициите се случва отгоре надолу.
-- Тоест, ако подадем отрицателно число - fact ще зацикли.

-- Дефиницията на списъците в Prelude:
-- 1) [] - празния списък
-- 2) x : xs - елемент x залепен за списък xs
--  * Важно е че ако x :: a, то xs :: [a]

-- Съответно можем да съпоставяме по [] и (:) за стандартните списъци
map :: (a -> b) -> [a] -> [b]
map _ [] = []
map f (x:xs) = f x : map f xs
-- Не забравяйте за скобите в (x:xs)

-- map еквивалент на Scheme:
--
-- (define (map f xs)
--    (if (null? xs)
--      xs
--      (cons (f (car xs))
--            (map f (cdr xs)))))

-- Можем да правим иманувани образци с @
headPlusLen :: [Int] -> Int
headPlusLen [] = 0
headPlusLen r@(x : _) = x + length r

-- * Ползвайте guard-ове само когато наистина се налага (булева проверка)!
-- * Във всички други случаи ползвайте pattern matching!

-- Вложени дефиниции:
---------------------
-- let е израз, с който можем да правим вложени дефиниции:
-- let <def1>
--     <def2>
--      ...
--     <defn>
--  in <body>
--
-- Пример:
circlePerimeter :: Float -> Float
circlePerimeter r =
  let pi = 3.14
   in 2 * pi * r

-- let в Haskell е подобна конструкция на letrec в scheme

-- Друга конструкция е where - не е израз и работи само в рамките на дефиниция:
-- <function-definition>
--    where <def1>
--          <def2>
--           ...
--          <defn>
--
-- Пример:
circleArea :: Float -> Float
circleArea r = pi * r * r
  where pi = 3.14

-- * Внимавайте с идентацията!

-- Списъци и генератори:
------------------------
-- Списъците в Haskell са потоци,
-- тоест се оценяват мързеливо и могат да са безкрайни.

-- Съответно всички стандартни функции за списъци,
-- работят и върху безкрайни списъци.

-- List generators:

-- Можем да генерираме списъци от последователни елементи (числа, символи и др.)
-- Генераторите на списъци са синтактична захар за enumFrom и други функции.

-- Безкраен списък с елементи започващи от n:
-- enumFrom n ~~> [n,n+1,n+2,...]
-- [n..]      ~~> [n,n+1,n+2,...]

-- Безкраен списък с елементи започващи от n и всеки следващ със стъпка m-n=k
-- enumFromThen n m ~~> [n,m,m+k,m+2k,...]
-- [n,m..]          ~~> [n,m,m+k,m+2k,...]

-- Списък от елементите от n до m
-- enumFromTo n m ~~> [n,n+1,...,m-1,m]
-- [n..m]         ~~> [n,n+1,...,m-1,m]
-- [10..1]        ~~> []
-- не можем да правим списъци с низходящи елементи!

-- Списък от елементите от n до най-много k, и стъпка m-n
-- enumFromThenTo n m k = [n,m..k]
-- [1,3..10] == [1,3,5,7,9]             ~~> True
-- [10,9..1] == [10,9,8,7,6,5,4,3,2,1]  ~~> True
-- така вече можем да правим списъци с низходящи елементи.

-- List comprehension:
-- -------------------
-- [<expr> | {<generator>}+, {<condition>}+]

-- generator е от вида: <pattern> <- [a]
-- където <pattern> пасва на елемент от тип a

-- крайният резултат е списък от <expr> за всеки елемент получен от <generator>
-- за който са изпълнени всички условия

-- Пример:
-- [(x,y) | x<-[1..10], y<-[1..10], odd x, even y]
-- всички двойки (x,y), такива че
-- x е от [1..10], y е от [1..10], x е нечетно и y е четно

-- * всички двойки означава всяко със всяко когато имаме 2 генератора

--------------------------------------------------------------------------------
-- ЗАДАЧИ --
------------

-- Типовете на елементите на списъка и акумулатора са различни
-- както ако в Scheme правите foldl върху списък от числа,
-- но с предикат и логическа връзка (and, or) натрупвате булева стойност
foldl :: (b -> a -> b) -> b -> [a] -> b
foldl = undefined

-- За дадени два списъка [a1, ..., an] и [b1, ..., bn],
-- връща списъка от наредени двойки [(a1,b1), ..., (an,bn)]
-- Да се покрие и случаят, в който списъците имат различна дължина
zip :: [a] -> [b] -> [(a, b)]
zip = undefined

-- Прилага поелементно функция върху двата списъка едновременно.
-- Връща списък от резултатите. Като map на 2 списъка в scheme
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
zipWith = undefined

-- Връща най-големия префикс на списък,
-- такъв че даденият предикат е изпълнен за всичките му елементи
takeWhile :: (a -> Bool) -> [a] -> [a]
takeWhile = undefined

-- за списък от цели числа, премахва дубликатите,
-- т.е. запазва само първите срещания на даден елемент
nub :: [Int] -> [Int]
nub = undefined

-- Проверява дали дадено число е просто
prime :: Int -> Bool
prime = undefined

-- За дадено число n връща списък от първите n прости (положителни) числа
primes :: Int -> [Int]
primes = undefined

-- За дадено естествено число, връща списък от простите му делители
-- factorize 60 = [2, 2, 3, 5]
factorize :: Int -> [Int]
factorize = undefined

-- quicksort за цели числа
quicksort :: [Int] -> [Int]
quicksort = undefined
