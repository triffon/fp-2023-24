#lang racket

; Наредени двойки:
;-----------------
; cons създава наредена 2-ка
(cons 1 #\a) ; (1 . #\a)
; Тук точката индикира че това е наредена 2-ка

(define some-pair (cons "first" "second"))

; Функции с които достъпваме елементите на наредена двойка:

; Първия елемент (Contents of the Address Register)
(car some-pair)   ; "hello"

; Втория елемент (Contents of the Data Register)
(cdr some-pair)   ; "world"


; Има съкратен синтаксис за композиция на car и cdr:
; caar - първия елемент на първия елемент
; cdar - втория елемент на първия елемент
; и т.н. до общо 4 срещания на "a" и "d"

(define deep-list
  (list (list 1 2)
        (list (list 3 4) 5)))

; Може да ги четете отзад напред за по-лесно
(caar deep-list)  ; 1
(cdar deep-list)  ; (2)


; Списъци:
;---------
; 1. '() е списък
; 2. (head . tail) е списък <=> tail е списък

(list 1 2 3 4) ; построява списък от подадените аргументи

; Ясно се вижда че списъците са наредени 2ки,
; но наредените 2ки не са списъци.
'(1 . (2 . (3 . (4 . 5))))  ; '(1 2 3 4 . 5)
'(1 . (2 . (3 . (4 . ())))) ; '(1 2 3 4)

(pair? '()) ; #f
(list? '()) ; #t
(null? '()) ; #t


; Списък може да се конструира и с quote
(quote (1 2 3 4))

; Но обикновено се използва съкратен синтаксис:
'(1 2 3 4)

; Каква е разликата дали ползваме list или quote?

; quote е специална форма и не оценява аргументите си,
; а се прилага "рекурсивно" върху тях
'(1 2 3)
; е същото като
(list '1 '2 '3)

; съответно ако има какво да се оцени
'(+ 1 2)  ; тук + е само символ
          ; (immutable string)

(list + 1 2)  ; тук + е процедура
; или ако на мястото на някой елемент сложим променлива
; quote ще вземе буквално името й като символ, а list
; ще я оцени

; Сравнения:
;-----------
; (= a b) работи само за числа

; (eq? a b) проверява дали a и b са един и същ обект
; (на едно и също място в паметта)

; (eqv? a b) е като eq? с изключение за някои типове
; на аргументите - като char и integer

; (equal? a b) e като eqv? с изключение за много типове.
; Работи за списъци и може да сравнява покомпонентно.


;===============;=========================================
;; З А Д А Ч И ;;
;;;;;;;;;;;;;;;;;

; NOTE: Суфикса * е защото съществуват вградени процедури
;       със същите имена в racket или r5rs

; 0. Намира дължина на списък
(define (length* lst) 'undefined)

; 1. Връща списък от първите n елемента
(define (take* n lst) 'undefined)

; 2. Връща списък като lst, но без първите n елемента
(define (drop* n lst) 'undefined)

; 3. Генерира списък от целите числа в интервала [a,b]
(define (from-to a b) 'undefined)

; 4. По даден списък от числа - намира сумата им.
(define (sum lst) 'undefined)

; 5. Връща последния елемент на списъка lst.
(define (last* lst) 'undefined)

; 6. Връща n-тия елемент на списъка lst.
(define (nth n lst) 'undefined)

; 7. Залепя l1 и l2 в списък от наредени 2ки.
; Може списъците да са с различна дължина.
; Пример: (zip '(1 2 3) '(4 5)) -> '((1 . 4) (2 . 5))
(define (zip l1 l2) 'undefined)

; 8. Връща конкатенацията на lst1 и lst2.
; Реализирайте с рекурсия
(define (append* lst1 lst2) 'undefined)

; 9. Връща lst след прилагане на f върху всеки елемент.
(define (map* f lst) 'undefined)

; 10. Връща списък от елементите на lst,
; за които предиката p е верен
(define (filter* p lst) 'undefined)

; 11. Като функцията accumulate, но за списъци
; Пример: (foldl* - 0 '(1 2 3 4)) -> -10
(define (foldl* op acc lst) 'undefined)

; 12. Като foldl, но рекурсивно
; Забележка: Началната стойност е десният аргумент на операцията
; Пример: (foldr* - 0 '(1 2 3 4)) -> -2
(define (foldr* op acc lst) 'undefined)
