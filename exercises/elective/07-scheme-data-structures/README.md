# 07. Структури от данни - матрици, дървета и асоциативни списъци

![Matrix meme](../assets/07-matrix-meme.jpeg)

---

[Безсрамно откраднато от миналата година](https://github.com/triffon/fp-2022-23/blob/main/exercises/cs2/06.scheme.data-structures) по модул форматиране :smile:

---

[Матрици](#матрици), [Двоични дървета](#двоични-дървета), [Асоциативни списъци](#асоциативни-списъци)

## Матрици

1. Напишете функция `(matrix-ref m i j)`,
   която връща елемент на позиция `i, j` в матрицата `m`.
   Пример: `(matrix-ref '((1 2 3) (4 5 6) (7 8 9)) 2 1) -> 8`

2. Напишете функция `(mat? m)`, която валидира, че m е матрица
   (всички елементи числа; редовете са с равни дължини)

3. Напишете функция `(delete-column i m)`, която връща матрица, представляваща `m`
   без `i`-тата си колона:

   ```scheme
   (delete-column 1 '((1 2 3 5)
                      (6 7 8 0)
                      (5 6 3 4)))
   ;; => '((1 3 5)
   ;;      (6 8 0)
   ;;      (5 3 4))
   ```

4. Напишете функция `(transpose m)`, която транспонира матрица.

   ```scheme
   (transpose '((1 2 3) (4 5 6) (7 8 9))) ;; => '((1 4 7) (2 5 8) (3 6 9))
   ```

5. Напишете функция `(map-matrix f m)`, която прилага `f` върху всеки от елементите на `m`.

6. (**БОНУС** 0.5 т.) Напишете функция `(main-diagonal m)`, която връща главния диагонал на матрицата `m`.

   ```scheme
   (main-diagonal '((1 2 3)
                    (4 5 6))) ;; => '(1 5)
   ```

7. Напишете функция `(dimensions m)`, която
връща наредена двойка с броя редове и броя колони на матрицата `m`.

   ```scheme
   (dimensions '((1 2 3) (4 5 6))) ;; => '(2 . 3)
   ```

8. Напишете функция `(reverse-columns m)`, която
обръща реда на колоните в матрицата `m`.

   ```scheme
   (reverse-columns '((1 2 3) (4 5 6) (7 8 9))) ;; => '((3 2 1) (6 5 4) (9 8 7))
   ```

9. Напишете функция `(nth-column m n)`, която
връща списък с елементите на `n`-тата поред колона от матрицата `m`.

   ```scheme
   (nth-column '((1 2 3) (4 5 6) (7 8 9)) 2) ;; => '(2 5 8)
   ```

10. Напишете предикат `(all-columns? p? m)`, който
проверява дали за всяка колона в матрицата `m` е изпълнен предикатът `p`.

11. Напишете предикат `(prime-in-each-column? m)`, който
проверява дали във всяка колона в матрицата `m` има просто число.

    ```scheme
    (prime-in-each-column? '((2 2 4) (4 5 6))) ;; => #f
    ```

    ```scheme
    (prime-in-each-column? '((17 2 16) (4 5 3))) ;; => #t
    ```

12. (**БОНУС** 1.5 т.) Напишете функция `(multiply m1 m2)`, която
  връща произведението на двете матрици `m1` и `m2`.

13. (**БОНУС** 1 т.) Напишете функция `(find-columns m)`, която
  намира броят на колоните, за които е вярно, че
  всичките им елементи се срещат в някой от редовете на матрицата.

   ```scheme
   (find-columns '((1 4 3) (4 5 6) (7 4 9))) ;; => 1
   ```
   защото `4`, `5` и `4` от втората колона се срещат във втория ред.

## Двоични дървета

1. Абстракция: `(make-tree root left right)`, `(root-tree tree)`, `(left-tree tree)`,
   `(right-tree tree)`, `(empty-tree? tree)`, `(leaf-tree? tree)`, `(tree? x)`

2. Напишете функции `(collect-pre-order t)`, `(collect-in-order t)` и `(collect-post-order t)`, които връща списък от елементите на дървото, обходено съотвено `корен-ляво-дясно`, `ляво-корен-дясно` и `ляво-дясно-корен`.

3. Напишете функция `(map-tree f t)`, която заменя всеки връх `x` от дървото `t` с `(f x)`.

4. Напишете функция `(height t)`, която намира височината на дървото `t`. Това е броят на върховете в най-дългия път.

5. (**БОНУС** 0.5 т.) Напишете функция `(level n t)`, която връща списък с всички върхове от дървото с дълбочина `n`.
> Дълбочината на един връх `x` от дърво е броят ребра, които го свързват с корена `r`. Това е равно и на броя върхове от `r` до `x`, без да броим `x`. Дълбочината на корена е 0.

6. Напишете функция `(count-leaves t)`, която връща броя листа на t.
> Листо е връх от дърво, който няма наследници.

7. Напишете функция `(remove-leaves t)`, която връща дървото t, премахвайки листата му.

8. (**БОНУС** 0.5 т.) Напишете функция `(invert t)`, която разменя левите поддървета на `t` с десните.

9. (**БОНУС** 0.5 т.) Напишете функция `(bst? t)`, която намира дали `t` е двоично **наредено** дърво.

10. (**БОНУС** 0.5 т.) Напишете функция `(insert-bst x t)`, която добавя елемент `x` в двоично **наредено** дърво `t`, запазвайки наредбата му.
> Така може да направите функция `(list->bst l)`, която по списък прави наредено дърво, и чрез някоя от `collect` функциите от задачa 1 може да реализирате сортиране на списък.

11. (**БОНУС** 0.5 т.) Двоично дърво е балансирано, ако:
   1. е празното двоично дърво или
   2. височините на лявото и дясното поддърво се различават най-много с 1 и
   лявото и дясното поддървета са балансирани.

   Напишете предикат `(balanced? tree)`, която
   проверява дали дървото `tree` е балансирано.


## Асоциативни списъци

1. Напишете функция `(index l)`, която връща асоциативен списък, в който всеки елемент `x` на `l` е асоцииран с ключ, равен на позицията на `x` в `l`.

2. (**БОНУС** 1 т.) Напишете функция `(update-or-insert default f key al)`, която приема асоциативния списък `al` (допускаме - без дублирани ключове) и
   - ако няма стойност, съответстваща на ключа `key`, то `v := default`;
   - ако има стойност, съответстваща на ключа `key`, то `v := нея`,
след което задава стойността, съответстваща на `key` в `al`, да е `(f v)`.

3. Напишете функция `(histogram l)`, която
   връща хистограма на срещанията на всички елементи в `l` под формата на асоциативен списък.

   ```scheme
   (histogram '(8 7 1 7 8 2 2 8 2 7 8 1)) ;; => '((8 . 4) (7 . 3) (1 . 2) (2 . 3))
   ```

4. (**БОНУС** 0.5 т.) Напишете функция, която в асоциативен списък изчиства дублирани ключове, като запазва само първата стойност.

5. Напишете функция, която слива два асоциативни списъка, като за общите ключове прилага двуместна операция подадена като аргумент.

6. (**БОНУС** 0.5 т.) Напишете функция, която композира два асоциативни списъка с целочислени ключове и стойности, разглеждайки ги като функции.
   Пример:

   ```scheme
   (compose '((1 . 2) (2 . 3) (3 . 4)) '((2 . 20) (4 . 40) (6 . 60))) ;; => '((1 . 20) (3 . 40))
   ```

   Разглеждайки асоциативните списъци като множества от наредени двойки, композицията на `al1` и `al2` е:
    $\{ <x, z> | <x, y> \in al1 \land <y, z> \in al2 \}$

7. Напишете функция `(group-by f l)`, която
   връща асоциативен списък, в който ключовете са стойностите на функцията `f` след прилагането ѝ върху елементи от списъка `l`, а
   срещу ключовете стои списък от елементите, за които функцията `f` дава стойността от ключа.

   ```scheme
    (group-by (lambda (x) (remainder x 3)) '(0 1 2 3 4 5 6 7 8)) ;; => '((0 0 3 6) (1 1 4 7) (2 2 5 8))
   ```

8. Напишете функция `(run-length-encode l)`, която
   кодира списъка `l` в асоциативен списък - списък от наредени двойки `'(<ключ> . <стойност>)`,
   където `<ключ>`-ът e пореден елемент от списъка `l`, а
   `<стойност>`-та е колко пъти се повтаря елемента последователно.

   ```scheme
    (run-length-encode '(8 7 7 2 2 2 2 3 3 2)) ;; => '((8 . 1) (7 . 2) (2 . 4) (3 . 2) (2 . 1))
   ```

9.  Напишете функция `(run-length-decode code)`, която
   възстановява списъка, който е кодиран чрез `run-length-encode` от предната задача
   в асоциативния списък `code`.

   ```scheme
    (run-length-decode '((1 . 2) (3 . 4) (5 . 2))) ;; => '(1 1 3 3 3 3 5 5)
   ```

## Задачи от контролни

### Задача 1. (10 т.) от 2017/18

Да се напише функция extremum, която по даден списък от
списъци от числа намира число, което е минимално или максимално във
всеки от списъците, ако има такова, или 0 иначе.

Пример: `extremum [[1,2,3,2],[3,5],[3,3],[1,1,3,3]] → 3`

Пример: `extremum [[1,2,3,2],[2,3,5],[3,3],[2,2,3,3]] → 0`

### Задача 2. от 2017/18

1. (6 т.) Да се напише функция clone t x y, която по дадено двоично
   дърво  от  числа  t получава  ново  със  зададен  корен  x и  две
   поддървета,  получени  от  t чрез  увеличаване  на  всичките  му
   елементи със зададено число y.

2. (6 т.) Двоично дърво наричаме “пълно”, ако има 2n елемента на ниво
   n. Да се напише функция  cloningTrees, която генерира безкраен
   поток от пълни дървета с височини съответно 1, 2, 3,..., като всички
   елементи на ниво n са със стойност n.

### Задача 3 от 2017/18

Телевизионно предаване се представя с наредена тройка от име
(низ), начален час (наредена двойка от час и минути) и продължителност
(брой  минути).  Телевизионна  програма  наричаме  последователност  от
предавания, чиито интервали на излъчвания са подредени в нарастващ ред
и не се пресичат.

1. (5 т.) Да се напише функция isProgram, което проверява дали даден
   списък от предавания е телевизионна програма.

2. (10 т.) Да се напише функция  diversestProgram, която по даден
   списък  от  телевизионни  предавания  генерира  възможно  най-
   разнообразна телевизионна програма, т.е. броят на различните (по
   име) предавания в нея е в максимален.

   Пример:
   ```haskell
   shows = [(“A”,(10,30),90),(“B”,(11,0),120)),(“C”,(12,0),15)]
   -- >>> isProgram shows → False
   -- >>> diversestProgram shows → [(“A”,(10,30),90),(“C”,(12,0),15)]
   ```

### Задача 4 (8 т.) [Scheme] от 2016/17

Да се напише функция  transformCount, която
преобразува  дърво  с  елементи  цели  числа  в  ново  дърво  със  същата
структура,  в  което  всеки  елемент  е  заменен  с  броя  на  елементите  в
поддървото с този корен в началното дърво.

Бонус (4 т.): transformCount да работи в O(n) време в най-лошия случай.
