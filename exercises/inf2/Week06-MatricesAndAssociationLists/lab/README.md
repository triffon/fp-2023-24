# Асоциативни списъци и матрици.

### Задача 1
Реализиайте процедура, която връща първата дадена стойност по подаден ключ в асоциативен списък. Ако такъв ключ няма, да се върне `#f`.

 - чрез рекурсия
 - чрез функции от по-висок ред
 - чрез `assoc`

```racket
(equal? (assoc-rec 1 (list '(2 . "Two") '(3 . "Three") '(1 . "One"))) "One")
(equal? (assoc-rec 4 (list '(2 . "Two") '(3 . "Three") '(1 . "One"))) #f)

(equal? (assoc-hop 1 (list '(2 . "Two") '(3 . "Three") '(1 . "One"))) "One")
(equal? (assoc-hop 4 (list '(2 . "Two") '(3 . "Three") '(1 . "One"))) #f)

(equal? (assoc-assoc 1 (list '(2 . "Two") '(3 . "Three") '(1 . "One"))) "One")
(equal? (assoc-assoc 4 (list '(2 . "Two") '(3 . "Three") '(1 . "One"))) #f)
```

### Задача 2
Реализирайте процедура, която по подаден ключ изтрива първата съответстваща двойка със същия ключ в асоциативен списък. Ако няма такъв ключ, да се върне същия списък.

```racket
(equal? (assoc-del 1 (list '(2 . "Two") '(3 . "Three") '(1 . "One"))) '((2 . "Two") (3 . "Three")))
(equal? (assoc-del 1 (list '(2 . "Two") '(3 . "Three"))) '((2 . "Two") (3 . "Three")))
```

### Задача 3
Реализирайте процедура `(replace xs dict)`, която заменя елементите в `xs`, които са ключове в `dict` със съответните им стойности в `dict`.

```racket
(equal? (replace '(1 2 3 4) '((1 . 11) (2 . 22))) '(11 22 3 4))
```

### Задача 4
Реализирайте процедура `make-f-alist`, която приема списък `xs` и унарна процедура `f`, която създава асоциативен списък с елементи от вида `(x . f(x))`.

```racket
(equal? (make-f-alist '(1 2 3) add1) '((1 . 2) (2 . 3) (3 . 4)))
```

### Задача 5
Реализирайте процедури `assoc-keys` и `assoc-values`, които приемат асоциативен списък и връщат съответно списък от ключовете и списък от стойностите.

```racket
(equal? (assoc-keys '((1 . "One") (2 . "Two") (3 . "Three"))) '(1 2 3))
(equal? (assoc-keys '()) '())

(equal? (assoc-values '((1 . "One") (2 . "Two") (3 . "Three"))) '("One" "Two" "Three"))
(equal? (assoc-values '()) '())

```

### Задача 6
Реализирайте процедура `zero-rows`, която приема матрица `xss` и връща модифицирана версия на същата матрица, при която, ако даден ред на оригиналната матрица съдържа поне една `0`, то в модифицираната матрица целият ред ще се състои само от `0`.

```racket
(equal? (zero-rows '((1 2 0) 
                     (3 4 1) 
                     (0 5 7) 
                     (4 2 4))) '((0 0 0) 
                                 (3 4 1) 
                                 (0 0 0) 
                                 (4 2 4)))
```

### Задача 7
Реализирайте процедура `zero-cols`, която приема матрица `xss` и връща модифицирана версия на същата матрица, при която, ако дадена колона на оригиналната матрица съдържа поне една `0`, то в модифицираната матрица цялата колона ще се състои само от `0`.

```racket
(equal? (zero-cols '((1 2 0)
                     (3 4 1)
                     (0 5 7)
                     (4 2 4))) '((0 2 0)
                                 (0 4 0)
                                 (0 5 0)
                                 (0 2 0)))
```

### Задача 8
Да се дефинира процедура `diagonals`, която приема матрица и връща точкова двойка от вида `( <главен диагонал> . <второстепенен диагонал>)`.

```racket
(equal? (diagonals '((1 2 3) (4 5 6) (7 8 9))) '((1 5 9) . (3 5 7))
(equal? (diagonals '((10 20) (30 40))) '((10 40) . (20 30))
(equal? (diagonals '((1 2 3 4) (5 6 7 8) (9 10 11 12))) '((1 6 11) . (4 6 9))
(equal? (diagonals '((100))) '((100) . (100))
```

### Задача 9
Да се дефинира предикат `triangular?`, който получава квадратна числова матрица и проверява дали тя е горно триъгълна, т.е. дали всички елементи под главния ѝ диагонал са нули.

```racket
(equal? (triangular? '((1 2 3)
                       (0 5 6)
                       (0 0 9))) #t)

(equal? (triangular? '((0 2 3)
                       (0 0 6)
                       (1 0 0))) #f)

(equal? (triangular? '((1 2 3)
                       (1 5 6)
                       (0 0 9))) #f)

(equal? (triangular? '((1 2 3 4)
                       (0 5 6 7)
                       (0 0 8 9)
                       (0 0 0 9))) #t)
```

### Задача 10
Да се дефинира процедура `spiral`, която получава матрица и връща списък, съдържт елементите на матрицата, обходена спираловидно.

```racket
(equal? (spiral '((1 2 3) (8 9 4) (7 6 5))) '(1 2 3 4 5 6 7 8 9))
```