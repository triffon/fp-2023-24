# Процедури от по-висок ред. Ламбда функции. Accumulate.

### Задача 1
Дефинирайте процедура от по-висок ред:
 - `my-identity`, която връща ламбда, връщаша това, което ѝ е подадено.
 - `my-lambda`, която приема процедура и връща ламбда, приемаща аргумент и връщаша резултата от процедурата, приложената върху аргумента
 - `negate-pred`, която приема предикат и връща ламбда, която приема аргумент и прилага отрицанието на предиката върху него
 - `my-compose`, която приема 2 процедури и връща тяхната композиция върху аргумент на ламбда

```racket
(= ((my-identity) 7) 7)
(equal? ((my-identity) "FMI") "FMI")

(= ((my-lambda identity) 7) 7)
(equal? ((my-lambda identity) "FMI") "FMI")
(= ((my-lambda string-length) "FMI") 3)

(equal? ((negate-pred even?) 6) #f)

(equal? ((my-compose even? string-length) "Tensorflow") #t)
(equal? ((my-compose (λ (x) (- x 5)) (λ (y) (+ y 25))) 5) 25)
```

### Задача 2
Напишете процедура от по-висок ред `complex-procedure`, която приема унарна процедура `f` и бинарна процедура `g` и връща ламбда на два аргумента, връщаща израза `g(f(x), f(y))`.

```racket
(= ((complex-procedure (λ (x) (* x 2)) (λ (x y) (+ x y))) 5 8) 26)
```

### Задача 3
Дефинирайте процедура от по-висок ред `apply-n`, която приема унарна процедура и я връща, приложена `n` на брой пъти.

```racket
(= ((apply-n (λ (x) (* 2 x)) 5) 2) 64)
(= ((apply-n (λ (x) (quotient x 10)) 2) 100) 1)
```

В задачите надолу ще използваме само и единствено:

```racket
(define (accumulate op nv a b term next)
    (if (> a b) nv
        (op (term a) (accumulate op nv (next a) b term next))))

(define (accumulate-i op nv a b term next)
    (if (> a b) nv
        (accumulate-i op (op nv (term a)) (next a) b term next)))
```

### Задача 4
Пресметнете сумата `2^3 + 5^3 + 8^3 + ... + n^3`, като реализирате процедура `cool-expression`.

```racket
(= (cool-expression 11) 1976)
(= (cool-expression 15) 4720)
```

### Задача 5
Реализирайте процедура `factorial`, която пресмята `n!`.

```racket
(= (factorial 5) 120)
(= (factorial 8) 40320)
```

### Задача 6
Реализиайте процедура `prime?`, която проверява дали дадено число е просто.

```racket
(equal? (prime? 1) #f)
(equal? (prime? 2) #t)
(equal? (prime? 3) #t)
(equal? (prime? 6) #f)
(equal? (prime? 42) #f)
(equal? (prime? 61) #t)
```

### Задача 7
Реализирайте процедура `all?`, която проверява дали всички числа в даден интервал изпълняват даден предикат.

```racket
(equal? (all? 100 999 (λ (x) (< x 1000))) #t)
(equal? (all? 1 100 odd?) #f)
```

### Задача 8
Реализирайте процедура `any?`, която проверява дали поне едно число в даден интервал изпълняваа даден предикат.

```racket
(equal? (any? 1001 1500 (λ (x) (< x 1000))) #f)
(equal? (any? 1 100 odd?) #t)
```

### Задача 9 (От Домашно 1, 2022/2023 г.)
Да се напише функция `(argmin f a b)`, която връща такова число от целочисления интервал `[a;b]`, за което едноместната функция `f` връща най-ниска стойност. Забележете, че върнатите от `f` стойности иначе не ни интересуват. При повече от един минимуми е без значение кой от тях ще бъде върнат.

```racket
(define (mod7 x) (remainder x 7))
(= (argmin mod7 45 50) 49)
```

### Задача 10
Напишете функция `count-digits`, която връща броя на цифрите на естествено число.

```racket
(= (count-digits 12345) 5)
(= (count-digits 0) 1)
```

### Задача 11
Напишете функция `count-pairs`, която приема 3 числа - `a`, `b` и `n`. Функцията да намира броя на двойките числа в интервала `[a;b]`, които имат сбор точно равен на `n` (броим двойките `(3, 7)` и `(7, 3)` като една).

```racket
(= (count-pairs 1 10 14) 4)
```